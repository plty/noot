package jlite.parser;

import java.util.*;
import java.io.*;
import java.util.*;
import java.util.stream.*;
import java.nio.file.Files;
import java.nio.file.Paths;

import java_cup.runtime.*;
import java_cup.runtime.SymbolFactory;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ScannerBuffer;
import java_cup.runtime.Symbol;

import jlite.lexer.Scanner;
import com.google.common.collect.ImmutableList;

parser code {:
    private List<String> lines;
    private String fileLoc;

    public parser(String fileLoc) throws Exception {
        super(new Scanner(new FileReader(fileLoc)), new ComplexSymbolFactory());
        this.fileLoc = fileLoc;
        this.lines = Files.readAllLines(Paths.get(fileLoc));
    }

   public static Ast.Program parse(String fileLoc) throws Exception {
        parser p = new parser(fileLoc);
        try {
            return (Ast.Program) p.parse().value;
        } catch (Exception e) {
            throw e;
        }
    }

    public static <T> List<T> prepend(T v, List<T> l) {
        return new ImmutableList.Builder<T>().add(v).addAll(l).build();
    }

    public static <T> List<T> append(T v, List<T> l) {
        return new ImmutableList.Builder<T>().addAll(l).add(v).build();
    }
:};

terminal LPAREN, RPAREN, LBRACE, RBRACE;
terminal COMMA, SEMI;

terminal CLASS, MAIN;
terminal VOID, BOOL, INT, STRING;
terminal IF, ELSE, WHILE, READLN, PRINTLN, RETURN;
terminal TRUE, FALSE;

terminal String CNAME;
terminal String ID;

non terminal Ast.Program program;
non terminal Ast.Main main_class;
non terminal Ast.Method main_method;

non terminal List<Ast.Cls> classes;
non terminal List<Ast.Method> methods;

non terminal List<Ast.Arg> args;
non terminal List<Ast.Arg> rest_args;
non terminal Ast.Body body;

non terminal List<Ast.Var> vars;
non terminal Ast.Var var;

non terminal Ast.Type type;
non terminal Ast.Id id;

non terminal Ast.Stmt stmt;
non terminal List<Ast.Stmt> stmts;
non terminal Ast.Block block;
non terminal List<Ast.Stmt> _block;

non terminal Ast.Expr expr;

program ::=
    main_class:mc classes:cs
          {: RESULT = new Ast.Program(mc, cs); :}
    ;

main_class ::=
      CLASS CNAME:name LBRACE main_method:m RBRACE
          {: RESULT = new Ast.Main(name, m); :}
    ;

main_method ::=
      VOID MAIN LPAREN args:args RPAREN body:body
          {: RESULT = new Ast.Method(new Ast.Id("main"), new Ast.Type("Void"), args, body); :}
    ;

classes ::=
      CLASS CNAME:name LBRACE vars:v methods:m RBRACE classes:rest
          {: RESULT = prepend(new Ast.Cls(name, v, m), rest); :}
    |
          {: RESULT = List.of(); :}
    ;

methods ::=
      type:t id:id LPAREN args:args RPAREN body:body methods:rest
          {: RESULT = prepend(new Ast.Method(id, t, args, body), rest); :}
    |
          {: RESULT = List.of(); :}
    ;

body ::=
      LBRACE vars:v stmts:s RBRACE
          {: RESULT = new Ast.Body(v, s); :}
    ;

id ::=
      ID:id
          {: RESULT = new Ast.Id(id); :}
    | MAIN
          {: RESULT = new Ast.Id("main"); :}
    ;

type ::=
      CNAME:c
          {: RESULT = new Ast.Type(c); :}
    | VOID
          {: RESULT = new Ast.Type("Void"); :}
    | BOOL
          {: RESULT = new Ast.Type("Bool"); :}
    | INT
          {: RESULT = new Ast.Type("Int"); :}
    | STRING
          {: RESULT = new Ast.Type("String"); :}
    ;

vars ::=
      vars:vs var:v
          {: RESULT = append(v, vs); :}
    |
          {: RESULT = List.of(); :}
    ;

var ::=
      type:t id:id SEMI
          {: RESULT = new Ast.Var(t, id); :}
    ;

args ::=
      type:t id:id rest_args:rest
          {: RESULT = prepend(new Ast.Arg(t, id), rest); :}
    |
          {: RESULT = List.of(); :}
    ;

rest_args ::=
      COMMA type:t id:id rest_args:rest
          {: RESULT = prepend(new Ast.Arg(t, id), rest); :}
    |
          {: RESULT = List.of(); :}
    ;

block ::=
      _block:b
          {: RESULT = new Ast.Block(b); :}
    ;

_block ::=
      LBRACE stmt:s stmts:rest RBRACE
          {: RESULT = prepend(s, rest); :}
    ;

stmts ::=
      stmt:s stmts:rest
          {: RESULT = prepend(s, rest); :}
    |
          {: RESULT = List.of(); :}
    ;

stmt ::=
      RETURN SEMI
          {: RESULT = new Ast.Return(null); :}
    | RETURN expr:e SEMI
          {: RESULT = new Ast.Return(e); :}
    | IF LPAREN expr:cond RPAREN block:cons ELSE block:alt
          {: RESULT = new Ast.If(cond, cons, alt); :}
    | WHILE LPAREN expr:cond RPAREN block:b
          {: RESULT = new Ast.While(cond, b); :}
    | READLN LPAREN id:id RPAREN SEMI
          {: RESULT = new Ast.Call(new Ast.Id("readln"), List.of(id)); :}
    | PRINTLN LPAREN expr:e RPAREN SEMI
          {: RESULT = new Ast.Call(new Ast.Id("println"), List.of(e)); :}
    ;

expr ::=
      id:id
          {: RESULT = id; :}
    | TRUE
          {: RESULT = new Ast.Lit(true); :}
    | FALSE
          {: RESULT = new Ast.Lit(false); :}
    ;