/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
package jlite.parser;

import java.util.*;
import java.io.*;
import java.util.*;
import java.util.stream.*;
import java.nio.file.Files;
import java.nio.file.Paths;

import java_cup.runtime.*;
import java_cup.runtime.SymbolFactory;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ScannerBuffer;
import java_cup.runtime.Symbol;

import jlite.lexer.Scanner;
import com.google.common.collect.ImmutableList;

parser code {:
    private List<String> lines;
    private String fileLoc;

    public parser(String fileLoc) throws Exception {
        super(new Scanner(new FileReader(fileLoc)), new ComplexSymbolFactory());
        this.fileLoc = fileLoc;
        this.lines = Files.readAllLines(Paths.get(fileLoc));
    }

   public static Ast.Program parse(String fileLoc) throws Exception {
        parser p = new parser(fileLoc);
        try {
            return (Ast.Program) p.parse().value;
        } catch (Exception e) {
            throw e;
        }
    }

    public static <T> List<T> prepend(T v, List<T> l) {
        return new ImmutableList.Builder<T>().add(v).addAll(l).build();
    }

    public static <T> List<T> append(T v, List<T> l) {
        return new ImmutableList.Builder<T>().addAll(l).add(v).build();
    }
:};

terminal LPAREN, RPAREN, LBRACE, RBRACE;
terminal COMMA, SEMI;

terminal CLASS, MAIN, RETURN;
terminal VOID, BOOL, INT, STRING;

terminal String CNAME;
terminal String ID;

non terminal Ast.Program program;
non terminal Ast.Main main_class;
non terminal Ast.Method main_method;

non terminal List<Ast.Cls> classes;
non terminal List<Ast.Method> methods;

non terminal List<Ast.Arg> args;
non terminal List<Ast.Arg> rest_args;
non terminal Ast.Body body;
non terminal List<Ast.Stmt> stmts;

non terminal List<Ast.Var> vars;
non terminal Ast.Var var;

non terminal Ast.Type type;
non terminal Ast.Id id;

program ::=
    main_class:mc classes:cs
          {: RESULT = new Ast.Program(mc, cs); :}
    ;

main_class ::=
      CLASS CNAME:name LBRACE main_method:m RBRACE
          {: RESULT = new Ast.Main(name, m); :}
    ;

main_method ::=
      VOID MAIN LPAREN args:args RPAREN body:body
          {: RESULT = new Ast.Method(new Ast.Id("main"), new Ast.Type("Void"), args, body); :}
    ;

classes ::=
      CLASS CNAME:name LBRACE vars:v methods:m RBRACE classes:rest
          {: RESULT = prepend(new Ast.Cls(name, v, m), rest); :}
    |
          {: RESULT = List.of(); :}
    ;

methods ::=
      type:t id:id LPAREN args:args RPAREN body:body methods:rest
          {: RESULT = prepend(new Ast.Method(id, t, args, body), rest); :}
    |
          {: RESULT = List.of(); :}
    ;

body ::=
      LBRACE vars:v stmts:s RBRACE
          {: RESULT = new Ast.Body(v, s); :}
    ;

stmts ::=
      RETURN SEMI
          {: RESULT = List.of(new Ast.Return(null)); :}
    ;

vars ::=
      vars:vs var:v
          {: RESULT = append(v, vs); :}
    |
          {: RESULT = List.of(); :}
    ;

var ::=
      type:t id:id SEMI
          {: RESULT = new Ast.Var(t, id); :}
    ;

type ::=
      CNAME:c
          {: RESULT = new Ast.Type(c); :}
    | VOID
          {: RESULT = new Ast.Type("Void"); :}
    | BOOL
          {: RESULT = new Ast.Type("Bool"); :}
    | INT
          {: RESULT = new Ast.Type("Int"); :}
    | STRING
          {: RESULT = new Ast.Type("String"); :}
    ;

args ::=
      type:t id:id rest_args:rest
          {: RESULT = prepend(new Ast.Arg(t, id), rest); :}
    |
          {: RESULT = List.of(); :}
    ;

rest_args ::=
      COMMA type:t id:id rest_args:rest
          {: RESULT = prepend(new Ast.Arg(t, id), rest); :}
    |
          {: RESULT = List.of(); :}
    ;

id ::=
      ID:id
          {: RESULT = new Ast.Id(id); :}
    | MAIN
          {: RESULT = new Ast.Id("main"); :}
    ;
